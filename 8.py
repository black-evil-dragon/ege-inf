# Все пятибуквенные слова, в составе которых могут быть только русские буквы К, О, Ф, Е, записаны в
# алфавитном порядке и пронумерованы начиная с 1.

# Ниже приведено начало списка.
# 1. ЕЕЕЕЕ
# 2. ЕЕЕЕК
# 3. ЕЕЕЕО
# 4. ЕЕЕЕФ
# 5. ЕЕЕКЕ
# …
# Определите сумму номеров первого и последнего слов в списке,
# в которых только одна буква О и при этом никакая согласная буква не стоит рядом с буквой О.
"""
from itertools import *

words = product('екоф', repeat=5)

k = 0
j = 0

for word in words:
    k += 1
    word = list(''.join(word))
    if word.count('о') == 1:
        for i in range(len(word)):
            if word[i] in 'е':
                word[i] = '0'
            elif word[i] in 'кф':
                word[i] = '1'
        if '1о' not in ''.join(word) and '1о1' not in ''.join(word) and 'о1' not in ''.join(word):
            j = k + 3

print(j)
"""



# Аня составляет 5-буквенные слова из букв К, A, Р, П, Ы.
# Каждая буква может встречаться ровно один раз.
# При этом в слове не могут стоять рядом две гласные буквы,
# а буква Р не может стоять на первом или последнем месте.
# Словом считается любая допустимая последовательность букв, не обязательно осмысленная.
# Сколько слов может составить Аня?
"""
from itertools import *

k = 0
words = product('карпы', repeat=5)

for word in words:
    if len(set(word)) == 5:
        word = list(''.join(word))
        if word[0] != 'р' and word[-1] != 'р':
            for i in range(len(word)):
                if word[i] in 'аы':
                    word[i] = '0'
                else:
                    word[i] = '1'

            if '00' not in ''.join(word):
                k += 1
print(k)
"""



# Определите количество шестизначных чисел,
# записанных в семеричной системе счисления,
# в записи которых ровно одна цифра 6,
# при этом чётные и нечётные цифры чередуются.
"""
jopa = []

for x in '123456':
    for y in '0123456':

        for m in '0123456':
            for n in '0123456':

                for p in '0123456':
                    for k in '0123456':
                        s = x + y + m + n + p + k
                        f = list(s)

                        if s.count('6') == 1:
                            for i in range(len(s)):
                                if int(f[i]) % 2 == 0:
                                    f[i] = '0'
                                else:
                                    f[i] = '1'
                            s = ''.join(f)

                            if '00' not in s and '11' not in s:
                                jopa.append(s)

print(len(jopa))
"""


# Ученые хотят дать название своему новому изобретению,
# которое должно состоять из 10 различных строчных латинских букв,
# при этом в названии должно быть не менее двух гласных букв.
# Необходимо найти количество вариантов всевозможных названий.
# Примечание: в латинском алфавите 26 букв, из которых 5 - гласные.
"""
from math import factorial as f

print(
    f(26)/f(26-10) - f(21)/f(21-10) - 10*5*f(21)/f(21-9)
)
"""

# Определите количество пятизначных чисел,
# записанных в восьмеричной системе счисления,
# запись которых не начинается с нечётных цифр,
# не оканчивается цифрами 2 или 6,
# а также не содержит более двух цифр 7.
"""
k = 0
for x in '246':
    for y in '01234567':
        for m in '01234567':
            for n in '01234567':
                for p in '013457':
                    s = x + y + m + n + p

                    if s.count('7') <= 2:
                        k += 1
print(k)

"""

# Сколько можно составить различных кодов,
# в составе которых встречаются две подряд идущие гласные,
# путём перестановки букв слова СОТОЧКА?
"""
from itertools import *

k = 0
comb = ['оо', 'оа', 'аа', 'ао']

for i in set(permutations('соточка')):
    s = ''.join(i)

    if any(
        [y in s for y in comb]
    ): k += 1

print(k)
"""

# Полина составляет коды из букв слова ПОЛИНА.
# Код должен состоять из 8 букв,
# любую букву можно использовать произвольное число раз или не использовать вовсе.
# Полина хочет, чтобы согласных в каждом коде было больше, чем гласных. Сколько кодов,
# удовлетворяющих этому условию, она сможет составить?

"""
from itertools import *

word = 'полина'
k = 0

words = product(word, repeat=8)

for i in words:
    word = list(''.join(i))

    for j in range(len(word)):
        if word[j] in 'плн':
            word[j] = '1'
        else:
            word[j] = '0'

    if word.count('1') > word.count('0'):
        k += 1

print(k)
"""



# Леся составляет словосочетания длины 5 из пробела и букв своего имени.
# При этом никакие две гласные и две согласные не стоят рядом.
# Словосочетанием считается два слова, разделённых между собой пробелом.
# Слова не обязательно должны быть осмысленными словами русского языка.
# Сколько различных словосочетаний может составить Леся?
"""
from itertools import *

word = 'леся '
k = 0

words = product(word, repeat=5)

for i in words:
    word = list(''.join(i))

    if word[0] != ' ' and word[-1] != ' ' and word.count(' ') == 1:
        for j in range(len(word)):
            if word[j] in 'лс':
                word[j] = '1'
            elif word[j] in 'ея':
                word[j] = '0'
        word = ''.join(word)

        if '11' not in word and '00' not in word:
            k += 1

print(k)
"""



# Для составления цепочек используются бусины,
# помеченные буквами A, B, C, D, и E.
# В конце цепочки может стоять одна из бусин, помеченная согласной буквой.
# На втором месте — одна из бусин А, В, С, не стоящая в цепочке на первом месте.
# В начале — любая гласная, если третья буква согласная, и любая согласная, если третья гласная.
# Каждая из допустимых бусин может встречаться в цепочке любое количество раз или не встречаться совсем.

# Сколько цепочек длины 4 можно составить по данным правилам?
"""
from itertools import *

word = 'abcde'
k = 0

words = product(word, repeat=4)

for i in words:
    word = list(''.join(i))

    if word[-1] in 'bcd':
        if word[1] in 'abc' and word[1] != word[0]:
            if word[0] in 'ae' and word[2] in 'bcd' or word[0] in 'bcd' and word[2] in 'ae':
                k += 1

print(k)
"""



# Робот передвигается по доске 11 x 11 клеток. Ходить он может только двумя способами:
# 1) ВПРАВО на 1 клетку.
# 2) ВНИЗ на 1 клетку.
# Робот начинает движение в левом верхнем углу поля,
# заканчивает в правом нижнем.
#
# Вопрос: сколько существует способов добраться из стартовой позиции в финишную?
"""
from itertools import *

word = 'vp'
k = 0

words = product(word, repeat=(11-1)*2)

for i in words:
    word = list(''.join(i))

    if word.count('v') == word.count('p'):
        k += 1

print(k)
"""
